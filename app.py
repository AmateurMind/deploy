import streamlit as st
import html
import streamlit.components.v1 as components
import base64

st.set_page_config(page_title="PIC Programs", layout="wide")

# Hide the main area watermark and menu
st.markdown("""
    <style>
        
    </style>
""", unsafe_allow_html=True)

# Image paths for interfacing diagrams
image_paths = ["2exp.jpg", "3exp.jpg", "PIC_page-0003.jpg", "PIC_page-0004.jpg", "PIC_page-0005.jpg", "PIC_page-0006.jpg", "PIC_page-0007.jpg", "PIC_page-0008.jpg"]

PIC_PROGRAMS = {
    
    "Convolutional codes": r"""
clc;
clear all; 
close all;
coderate = 0.5; 
cons_len = input('Enter constraint length: '); % e.g., enter 3
% Input the message as a binary vector
m = input('Enter the Message (binary vector, e.g. [1 0 1 0 0]): ');   

% Define the trellis structure for convolutional encoding 
trellis = poly2trellis(cons_len, [5, 7]); 

% Perform convolutional encoding 
c = convenc(m, trellis); 

% Simulated received signal (should be a vector of bits)
% Example: noisy or hard decision bits
r = c; % For testing, assume no errors

% Alternatively, to simulate errors, flip some bits manually
% r = c;
% r(3) = ~r(3); % flip 3rd bit

% Set traceback length (tblen)
tblen = min(5, length(r)); % Ensure tblen is not larger than length of r


% Perform Viterbi decoding 
cc = vitdec(r, trellis, tblen, 'trunc', 'hard');

% Display the results  
disp('Original Message:');
disp(m);

disp('Encoded Message:'); 
disp(c); 

disp('Received Message (input to decoder):');
disp(r);

disp('Decoded Message: '); 
disp(cc);
""",
    "Huffman code ": r"""
//Write a code for generation of Huffman code for the symbols [AEHNGS} generated by DMS with probabilities [0.19, 0.15, 0.2, 0.16, 0.4, 0.08] and decode for the 01011101010100]. Calculate efficiency of the codeword.
x=input('enter the number of symbols:');
N=1:x;
disp('The number of symbols are N:');
disp(N);
p=input('enter the probabilities:');
disp(p);
s=sort(p,'descend');
disp('The sorted probabilities are:');
disp(s);
[dict,avglen]=huffmandict(N,s);
disp('The average length of code is:');
disp(avglen);
H=0;
for i=1:x
    H=H+(p(i)*log2(1/p(i)));
end
disp('Entropy is:');
disp(H);
disp('bits/msg');
E=(H/avglen)*100;
disp('Efficiency is:');
disp(E);
codeword=huffmanenco(N,dict);
disp('The codeword is:');
disp(codeword);
decode=huffmandeco(codeword,dict);
disp('Decoded output is:');
disp(decode);

""",
"LBC": r"""
Write a code for a systematic (7, 4) LBC, the parity matrix is given by
[ 110; 011;111;101]
i) Construct generator matrix
ii) Find all code vectors for messages
iii) If the received code vector is R=0111101

Code:

clear;
clc;
k = input('Enter number of message bits: ');
n = input('Enter number of code words: ');
P = input('Enter the parity matrix: ');
disp('Parity matrix:');
disp(P);
% --- Generator and Parity Check Matrices ---
G = [eye(k, k) P];
disp('Generator Matrix G:');
disp(G);
H = [P' eye(n - k, n - k)];
disp('Parity Check Matrix H:');
disp(H);
% --- Message Encoding ---
All_M = input('Enter the message bits: ');
CodedMat = All_M * G;
CodedMat = mod(CodedMat, 2);   
disp('Codewords Matrix:');
disp(CodedMat);

% --- Hamming Distance ---
HamDist = sum(CodedMat, 2);
[row, col] = find(HamDist == 0);
HamDist(row, :) = [];
MinHamDist = min(HamDist);
disp('Minimum non-Zero Hamming Distance:');
disp(MinHamDist);

ErrDetCap = MinHamDist - 1;
disp('Error Detection Capability:');
disp(ErrDetCap);

ErrCorCap = floor((MinHamDist - 1) / 2);
disp('Error Correction Capability:');
disp(ErrCorCap);

% --- Received Message ---
R = input('Enter received message: ');
disp('Received Codeword R:');
disp(R);

% --- Syndrome Calculation ---
S = mod(R * H', 2);     
disp('Syndrome Matrix R*H(transpose):');
disp(S);

% --- Error Detection / Correction ---
if isequal(S, zeros(1, n - k))
    disp('Received Code without error:');
    disp(R);
else
    disp('Error detected!');
    % Find column in H matching the syndrome
    [~, ErrPos] = ismember(S, H', 'rows');
    if ErrPos > 0
        disp(['Erroneous Bit Position: ', num2str(ErrPos)]);
        R(ErrPos) = mod(R(ErrPos) + 1, 2);
        disp('Received Code with error corrected:');
        disp(R);
    else
        disp('Unable to locate single-bit error.');
    end
end

disp('Received Information Message:');
disp(R(1:k));

""",
    "M-ARY PSK QAM": r"""

    Write a program to generate and plot constellation diagrams for different modulation schemes such as PSK and QAM, and to observe the effect of increasing modulation order (M).
clc; clear; close all;

% Define M for different modulation schemes (e.g., 4-PSK, 16-QAM)
M = 4;                      % Choose M (e.g., 4 for QPSK or 16 for 16-QAM)
x = 0:M-1;                  % Symbol indices

% --- PSK Modulation ---
disp('PSK Constellation Diagram:');
figure;
scatterplot(pskmod(x, M));  % Plot PSK constellation
title('4-PSK Constellation');
grid on;

% --- QAM Modulation ---
disp('QAM Constellation Diagram:');
y = qammod(x, M);           % Generate QAM symbols
y = y / norm(y, 'fro');     % Normalize the QAM signal
figure;
scatterplot(y);             % Plot QAM constellation
title('4-QAM Constellation');
grid on;

% --- Higher-order modulation ---
M = 16;                     % For example, 16-QAM or 16-PSK
x = 0:M-1;                  % Update the symbol indices for new M

% PSK Modulation for higher M
disp('Higher Order PSK Constellation Diagram:');
figure;
scatterplot(pskmod(x, M));  % Plot higher-order PSK constellation
title('16-PSK Constellation');
grid on;

% QAM Modulation for higher M
disp('Higher Order QAM Constellation Diagram:');
y = qammod(x, M);           % Generate QAM symbols for new M
y = y / norm(y, 'fro');     % Normalize
figure;
scatterplot(y);             % Plot higher-order QAM constellation
title('16-QAM Constellation');
grid on;

    """,

    

    "m ary psk qam noise ": r"""
Simulation of PSK Modulation with AWGN Noise at Different SNR Levels
M = 4; 
x = randi([0 M-1],1000,1);      
y1 = pskmod(x,M);           
% --- Case 1: SNR = 10 dB
SNRdB = 10;
SNR = 10^(SNRdB/10);
signal_power = mean(abs(y1).^2);
noise_power = signal_power / SNR;
noise = sqrt(noise_power/2) * (randn(size(y1)) + 1i*randn(size(y1)));
y1n = y1 + noise;

scatterplot(y1n);              
ylr = pskdemod(y1n,M);         
[num_error, er_rate] = symerr(x,ylr)
% --- Case 2: SNR = 5 dB
SNRdB = 5;
SNR = 10^(SNRdB/10);
noise_power = signal_power / SNR;
noise = sqrt(noise_power/2) * (randn(size(y1)) + 1i*randn(size(y1)));
y1n = y1 + noise;
scatterplot(y1n);
ylr = pskdemod(y1n,M);         
[num_error, er_rate] = symerr(x,ylr)

""",

    "Rabdom Process": r"""
Simulation  study of random process . find various  statistical  parameters of the random  process .
clc;
clear;
close all;
N = 1000;              % Number of samples
x = randn(1, N);       % Generate random signal (Gaussian noise)

m = mean(x);           % Mean
med = median(x);       % Median
r = xcorr(x, 'unbiased'); % Autocorrelation
v = var(x);            % Variance
rg = range(x);         % Range
s = std(x);            % Standard deviation

% Display values
disp(['Mean = ', num2str(m)]);
disp(['Median = ', num2str(med)]);
disp(['Variance = ', num2str(v)]);
disp(['Range = ', num2str(rg)]);
disp(['Standard Deviation = ', num2str(s)]);

% Plot random process
figure;
plot(x);
title('Random Process');
xlabel('Sample Index');
ylabel('Amplitude');

% Plot autocorrelation
figure;
plot(r);
title('Autocorrelation');
xlabel('Lag');
ylabel('Correlation Value');

"""
}

st.sidebar.title("Shhhhhhhh!!")
sel = st.sidebar.radio("Select", list(PIC_PROGRAMS.keys()))

# Show code for selections
code = PIC_PROGRAMS[sel]

# Create a JS-safe version of the raw code to copy via clipboard (escape backticks and backslashes)
js_safe = code.replace('\\','\\\\').replace('`','\\`')

# Persistent copy button in the sidebar — always available and will copy the raw code even if the
# main code panel is not visible.
with st.sidebar:
    components.html(f"""
    <div style='padding:6px;display:flex;justify-content:flex-end;'>
        <button style='padding:6px 10px;border-radius:4px;border:none;background:#28a745;color:#fff;cursor:pointer;font-weight:600;' onclick="navigator.clipboard.writeText(`{js_safe}`)">Copy</button>
    </div>
    """, height=60)

pre_id = f"code_{abs(hash(sel))}"
esc = html.escape(code)
components.html(f"""
<div style='background:#f1f1f1;padding:10px;border-radius:6px;position:relative;'>
    <button style='position:absolute;top:8px;left:8px;padding:6px 10px;border-radius:4px;border:none;background:#007bff;color:#fff;cursor:pointer;z-index:2;font-weight:600;display:inline-flex;align-items:center;gap:4px;' 
        onclick="(() => {{
            const btn = event.target;
            const text = document.getElementById('{pre_id}').innerText;
            navigator.clipboard.writeText(text)
                .then(() => {{
                    btn.innerHTML = '✓ Copied';
                    setTimeout(() => btn.innerHTML = 'Copy', 1000);
                }})
                .catch(err => alert('Failed to copy: ' + err));
        }})()">Copy</button>
    <pre id='{pre_id}' style='white-space:pre-wrap;font-family:monospace;margin-top:36px;max-height:500px;overflow-y:auto;'>{esc}</pre>
</div>
""",height=700)

# Keep the download button but hide code display
if sel:
    st.download_button("Download", code, file_name=sel+".c")
